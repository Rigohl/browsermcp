/// VULNERABILITY SCANNER - OWASP Top 10 Detection
/// Detecta: SQL Injection, XSS, CSRF, etc.
/// Analiza: formularios, endpoints, cookies, headers

use regex::Regex;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::HashMap;


#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityScan {
    pub scan_id: String,
    pub url: String,
    pub timestamp: String,
    pub vulnerabilities: Vec<Vulnerability>,
    pub severity_summary: SeveritySummary,
    pub owasp_violations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub cwe_id: String, // CWE identifier
    pub title: String,
    pub description: String,
    pub severity: String, // "critical", "high", "medium", "low"
    pub cvss_score: f32,
    pub location: String, // HTML element/endpoint
    pub evidence: String, // What was found
    pub remediation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SeveritySummary {
    pub critical: u32,
    pub high: u32,
    pub medium: u32,
    pub low: u32,
    pub total: u32,
}

/// Vulnerability Scanner
pub struct VulnerabilityScanner {
    patterns: HashMap<String, VulnPattern>,
}

#[derive(Debug, Clone)]
struct VulnPattern {
    regex: Regex,
    vuln_type: String,
    severity: String,
    cwe: String,
    description: String,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        let mut patterns = HashMap::new();

        // SQL Injection patterns
        patterns.insert(
            "sql_injection".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(union|select|insert|update|delete|drop|create|alter)\s*\(").unwrap(),
                vuln_type: "SQL Injection".to_string(),
                severity: "critical".to_string(),
                cwe: "CWE-89".to_string(),
                description: "Input appears to contain SQL keywords without proper escaping".to_string(),
            },
        );

        // XSS patterns
        patterns.insert(
            "xss".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(<script|javascript:|onerror=|onload=|onclick=)").unwrap(),
                vuln_type: "Cross-Site Scripting (XSS)".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-79".to_string(),
                description: "HTML/JavaScript code patterns detected without proper sanitization".to_string(),
            },
        );

        // CSRF token missing
        patterns.insert(
            "csrf".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)<form.*method=.*post").unwrap(),
                vuln_type: "CSRF Token Missing".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-352".to_string(),
                description: "POST form detected without CSRF token verification".to_string(),
            },
        );

        // Sensitive data in HTML
        patterns.insert(
            "sensitive_data".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(password|api_key|secret|token|credit_card)\s*=").unwrap(),
                vuln_type: "Sensitive Data Exposure".to_string(),
                severity: "critical".to_string(),
                cwe: "CWE-200".to_string(),
                description: "Sensitive data (passwords, API keys) possibly exposed in HTML".to_string(),
            },
        );

        // Weak SSL/TLS
        patterns.insert(
            "weak_ssl".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(tlsv1\.|sslv3|sslv2|md5|sha1)").unwrap(),
                vuln_type: "Weak SSL/TLS".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-327".to_string(),
                description: "Weak cryptographic algorithms detected".to_string(),
            },
        );

        // Insecure deserialization
        patterns.insert(
            "insecure_deserial".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(serialize|pickle|unserialize|deserialize)").unwrap(),
                vuln_type: "Insecure Deserialization".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-502".to_string(),
                description: "Deserialization functions detected that may accept untrusted data".to_string(),
            },
        );

        // XML External Entity (XXE)
        patterns.insert(
            "xxe".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(<!ENTITY|SYSTEM|PUBLIC|DOCTYPE)").unwrap(),
                vuln_type: "XML External Entity (XXE)".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-611".to_string(),
                description: "XML entity declarations detected that may be exploitable".to_string(),
            },
        );

        // Command Injection
        patterns.insert(
            "command_injection".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(exec|system|passthru|shell_exec|proc_open)\s*\(").unwrap(),
                vuln_type: "Command Injection".to_string(),
                severity: "critical".to_string(),
                cwe: "CWE-78".to_string(),
                description: "Command execution functions detected with potentially unsafe input".to_string(),
            },
        );

        // Path Traversal
        patterns.insert(
            "path_traversal".to_string(),
            VulnPattern {
                regex: Regex::new(r"(?i)(\.\.\/|\.\.\\|\.\./|\.\.\)").unwrap(),
                vuln_type: "Path Traversal".to_string(),
                severity: "high".to_string(),
                cwe: "CWE-22".to_string(),
                description: "Path traversal sequences detected in URL or parameters".to_string(),
            },
        );

        VulnerabilityScanner { patterns }
    }

    /// Escanear HTML en busca de vulnerabilidades
    pub fn scan_html(&self, url: &str, html: &str) -> VulnerabilityScan {
        let mut vulns = Vec::new();
        let mut severity_map: HashMap<String, u32> = HashMap::new();
        severity_map.insert("critical".to_string(), 0);
        severity_map.insert("high".to_string(), 0);
        severity_map.insert("medium".to_string(), 0);
        severity_map.insert("low".to_string(), 0);

        // Scan each pattern
        for (key, pattern) in self.patterns.iter() {
            if let Some(mat) = pattern.regex.find(html) {
                let evidence = &html[mat.start().saturating_sub(50)..mat.end().saturating_add(50)];
                
                vulns.push(Vulnerability {
                    id: format!("{}_{}", key, chrono::Utc::now().timestamp()),
                    cwe_id: pattern.cwe.clone(),
                    title: pattern.vuln_type.clone(),
                    description: pattern.description.clone(),
                    severity: pattern.severity.clone(),
                    cvss_score: match pattern.severity.as_str() {
                        "critical" => 9.8,
                        "high" => 7.5,
                        "medium" => 5.0,
                        "low" => 2.5,
                        _ => 0.0,
                    },
                    location: url.to_string(),
                    evidence: evidence.to_string(),
                    remediation: self.get_remediation(&pattern.vuln_type),
                });

                *severity_map.get_mut(&pattern.severity).unwrap() += 1;
            }
        }

        // Escanear headers de seguridad
        vulns.extend(self.check_security_headers(html));

        // Escanear cookies inseguras
        vulns.extend(self.check_insecure_cookies(html));

        let total = vulns.len() as u32;

        VulnerabilityScan {
            scan_id: format!("scan_{}", uuid::Uuid::new_v4()),
            url: url.to_string(),
            timestamp: chrono::Utc::now().to_rfc3339(),
            vulnerabilities: vulns,
            severity_summary: SeveritySummary {
                critical: severity_map["critical"],
                high: severity_map["high"],
                medium: severity_map["medium"],
                low: severity_map["low"],
                total,
            },
            owasp_violations: self.get_owasp_violations(&severity_map),
        }
    }

    /// Verificar headers de seguridad
    fn check_security_headers(&self, _html: &str) -> Vec<Vulnerability> {
        vec![
            // X-Frame-Options
            // X-Content-Type-Options
            // Content-Security-Policy
            // Strict-Transport-Security
        ]
    }

    /// Verificar cookies inseguras
    fn check_insecure_cookies(&self, html: &str) -> Vec<Vulnerability> {
        let mut vulns = Vec::new();

        // Check for cookies without HttpOnly
        if html.contains("Set-Cookie") && !html.contains("HttpOnly") {
            vulns.push(Vulnerability {
                id: format!("cookie_httponly_{}", chrono::Utc::now().timestamp()),
                cwe_id: "CWE-1004".to_string(),
                title: "Cookie Missing HttpOnly Flag".to_string(),
                description: "Cookies without HttpOnly flag can be accessed via JavaScript".to_string(),
                severity: "medium".to_string(),
                cvss_score: 5.0,
                location: "Set-Cookie header".to_string(),
                evidence: "HttpOnly flag not set".to_string(),
                remediation: "Add HttpOnly flag to all sensitive cookies".to_string(),
            });
        }

        // Check for cookies without Secure flag
        if html.contains("Set-Cookie") && !html.contains("Secure") {
            vulns.push(Vulnerability {
                id: format!("cookie_secure_{}", chrono::Utc::now().timestamp()),
                cwe_id: "CWE-614".to_string(),
                title: "Cookie Missing Secure Flag".to_string(),
                description: "Cookies without Secure flag can be transmitted over HTTP".to_string(),
                severity: "high".to_string(),
                cvss_score: 7.5,
                location: "Set-Cookie header".to_string(),
                evidence: "Secure flag not set".to_string(),
                remediation: "Use HTTPS only and add Secure flag to all cookies".to_string(),
            });
        }

        vulns
    }

    /// Obtener remediaciÃ³n
    fn get_remediation(&self, vuln_type: &str) -> String {
        match vuln_type {
            "SQL Injection" => "Use prepared statements and parameterized queries. Never concatenate user input into SQL.".to_string(),
            "Cross-Site Scripting (XSS)" => "Sanitize all user input, use output encoding, implement CSP headers.".to_string(),
            "CSRF Token Missing" => "Implement CSRF tokens on all state-changing operations.".to_string(),
            "Sensitive Data Exposure" => "Remove sensitive data from code, use environment variables, implement encryption.".to_string(),
            "Command Injection" => "Use safe APIs for process execution, avoid shell_exec/system.".to_string(),
            "Path Traversal" => "Validate and normalize file paths, use allowlists for permitted files.".to_string(),
            _ => "Review security best practices and apply appropriate fixes.".to_string(),
        }
    }

    /// Obtener violaciones OWASP
    fn get_owasp_violations(&self, severity_map: &HashMap<String, u32>) -> Vec<String> {
        let mut violations = Vec::new();

        if severity_map["critical"] > 0 {
            violations.push("A02:2021 - Cryptographic Failures".to_string());
        }
        if severity_map["high"] > 0 {
            violations.push("A03:2021 - Injection".to_string());
        }
        if severity_map["high"] > 0 {
            violations.push("A07:2021 - Cross-Site Scripting (XSS)".to_string());
        }

        violations
    }
}

impl VulnerabilityScan {
    /// Obtener conteo de vulnerabilidades
    pub fn vulnerability_count(&self) -> usize {
        self.vulnerabilities.len()
    }

    /// Filtrar vulnerabilidades por severidad
    pub fn filter_by_severity(&self, severity: &str) -> Vec<&Vulnerability> {
        self.vulnerabilities.iter()
            .filter(|v| v.severity == severity)
            .collect()
    }

    /// Generar reporte JSON
    pub fn to_json(&self) -> serde_json::Value {
        serde_json::to_value(self).unwrap_or(json!({}))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sql_injection_detection() {
        let scanner = VulnerabilityScanner::new();
        let html = r#"<input value="'; DROP TABLE users; --">"#;
        let result = scanner.scan_html("http://example.com", html);
        assert!(result.vulnerability_count() > 0);
        
        let sql_vulns: Vec<_> = result.vulnerabilities.iter()
            .filter(|v| v.cwe_id == "CWE-89")
            .collect();
        assert!(!sql_vulns.is_empty());
    }

    #[test]
    fn test_xss_detection() {
        let scanner = VulnerabilityScanner::new();
        let html = r#"<div onclick="alert('XSS')">"#;
        let result = scanner.scan_html("http://example.com", html);
        
        let xss_vulns: Vec<_> = result.vulnerabilities.iter()
            .filter(|v| v.cwe_id == "CWE-79")
            .collect();
        assert!(!xss_vulns.is_empty());
    }

    #[test]
    fn test_severity_summary() {
        let scanner = VulnerabilityScanner::new();
        let html = r#"<script>; DROP TABLE users; --</script>"#;
        let result = scanner.scan_html("http://example.com", html);
        
        assert!(result.severity_summary.critical > 0 || result.severity_summary.high > 0);
    }
}
